<!DOCTYPE html>
<html lang="zh-CN">

  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
  </head>

  <body>
    <script>
      //做一个工厂 用来生产人 这个对象
      //只要首字母是大写函数 -> 构造函数/构造器/类
      //内置构造函数/自定义构造函数
      //Number() new Array() Function() new Object()
      //生产一个人的实例
      //静态的属性 姓名 年龄
      //动态的方法 吃 睡
      //抽象 函数的传参来实现抽象
      function Person(name, age) {
        //2.为这个容器提供静态的属性
        this.name = name
        this.age = age
      }
      //eat 和 sleep 这两个东西 绑定 Person的原型(prototype)
      // Person.prototype 是个对象 原型对象
      //原型方法
      // 从该构造器中构造的实例 一定都能够直接使用这些原型方法
      Person.prototype.speak = function () {
        return this.name + "在吃"
      }
      Person.prototype.sleep = function () {
        return this.name + "在睡"
      }
      //调用Person这个构造函数来初始化一个p1实例
      // new 
      //1. this的指向恒定指向一个中介对象
      //2. 将这个中介对象一定会return出去
      let p1 = new Person("张三", 20)
      //调用Array这个构造函数来初始化一个arr实例
      // let arr = new Array()
      let p2 = new Person("李四", 20)
      p2.speak = function (){
        console.log("yes");
      }
      console.log(p1)
      console.log(p2)
      console.log(p1.eat === p2.eat) //原来是false 因为每个工程都会为该实例单独创建一个成员方法
      //现在 true 不在实例的本地创建该方法了 而是在 他们这些实例的原型上创建一个原型方法
      p2.speak();
    </script>
  </body>

</html>